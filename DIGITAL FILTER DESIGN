# FIR Filter Design — Verilog + MATLAB (Design + Simulation + Testbench)

**Deliverables contained in this document**

* MATLAB script: `design_and_export_fir.m` — designs an FIR (window method), plots responses, filters a test signal, and exports quantized coefficients for Verilog.
* Verilog RTL: `fir_q15.v` — parameterizable fixed-point FIR (Q1.15) supporting N taps.
* Verilog testbench: `tb_fir_q15.v` — applies impulse and a sample waveform, prints outputs for inspection.
* Instructions: How to run MATLAB, how to run Verilog simulation (Icarus/ModelSim), and what outputs to expect.

---

## 1) MATLAB script — `design_and_export_fir.m`

```matlab
% design_and_export_fir.m
% Usage: run this in MATLAB (or Octave with compatible functions)
% - Changes: set fs, cutoff, numTaps
% - It generates: coeffs in floating, plots, applies to test signal, and saves quantized Q15 coefficients to 'fir_coeffs_q15.txt'

clear; close all; clc;

% Parameters
fs = 48000;          % sampling frequency (Hz)
cutoff_hz = 6000;    % desired cutoff frequency (Hz)
numTaps = 16;        % number of taps (even or odd allowed); try 8, 16, 32

% Normalized cutoff (0..1) where 1 corresponds to Nyquist
Wn = cutoff_hz/(fs/2);

% Design: window method (Hamming window) — linear phase
b = fir1(numTaps-1, Wn, hamming(numTaps)); % 'b' are coefficients (length = numTaps)

% Frequency response
[H, f] = freqz(b,1,1024,fs);
figure; subplot(2,1,1);
plot(f, 20*log10(abs(H)+eps)); grid on; xlabel('Frequency (Hz)'); ylabel('Magnitude (dB)');
title(sprintf('%d-tap FIR magnitude response — cutoff %.1f Hz', numTaps, cutoff_hz));
subplot(2,1,2);
plot(f, unwrap(angle(H))); grid on; xlabel('Frequency (Hz)'); ylabel('Phase (radians)');

% Impulse response plot (should equal b)
figure; stem(0:length(b)-1, b, 'filled'); grid on; xlabel('n'); ylabel('h[n]'); title('FIR impulse response (coefficients)');

% Filter a sample signal: sum of two sinusoids (one below cutoff, one above)
t = (0:1/fs:0.01)';
sig = sin(2*pi*2000*t) + 0.6*sin(2*pi*12000*t); % 2 kHz (pass), 12 kHz (stop)
filtered = filter(b,1,sig);
figure; subplot(2,1,1); plot(t, sig); title('Input signal'); xlabel('Time (s)'); grid on;
subplot(2,1,2); plot(t, filtered); title('Filtered output'); xlabel('Time (s)'); grid on;

% Export quantized coefficients for Verilog (Q1.15 format)
% Q15 scaling factor
Q = 15;
scale = 2^Q;
q15 = round(b * scale);
% clamp to signed 16-bit range
q15(q15>32767) = 32767;
q15(q15<-32768) = -32768;

% Save to text file (one integer per line)
fid = fopen('fir_coeffs_q15.txt', 'w');
for k=1:length(q15)
    fprintf(fid, '%d\n', q15(k));
end
fclose(fid);

% Print to console so user can copy into Verilog easily
fprintf('%% MATLAB: Floating-point coefficients (b):\n');
fprintf('b = ['); fprintf(' %.8f', b); fprintf(' ]\n');
fprintf('%% Q15 integers (to put into Verilog array):\n');
fprintf('q15 = ['); fprintf(' %d', q15); fprintf(' ]\n');

fprintf('\nSaved quantized coefficients to fir_coeffs_q15.txt\n');

% Example frequency-domain verification: show attenuation at stopband
stopband_power_before = bandpower(sig, fs, [10000 14000]);
stopband_power_after  = bandpower(filtered, fs, [10000 14000]);
fprintf('Stopband power before: %.6f, after: %.6f (ratio %.2f dB)\n', stopband_power_before, stopband_power_after, 10*log10(stopband_power_before/stopband_power_after));
```

---

## 2) Verilog RTL — `fir_q15.v`

This is a parameterizable, synchronous FIR that accepts signed 16-bit input samples (Q1.15) and produces signed 32-bit accumulator output (you may shift/round to Q1.15 if desired). Coefficients are signed 16-bit Q15 integers (same format as MATLAB export).

```verilog
// fir_q15.v
// Simple direct-form FIR, single-cycle multiply-accumulate per sample (combinational MAC for small tap counts)
module fir_q15 #(
    parameter integer N = 16 // number of taps
) (
    input  logic clk,
    input  logic rst_n,
    input  logic signed [15:0] sample_in, // Q1.15
    input  logic valid_in,
    output logic signed [31:0] sample_out, // accumulator full precision
    output logic valid_out
);

    // Replace the following coefficient vector with the Q15 integers generated by MATLAB
    // Example placeholder values (replace these with actual numbers from fir_coeffs_q15.txt)
    localparam signed [15:0] coeffs [0:N-1] = '{16'sd0,16'sd0,16'sd0,16'sd0,16'sd0,16'sd0,16'sd0,16'sd0,16'sd0,16'sd0,16'sd0,16'sd0,16'sd0,16'sd0,16'sd0,16'sd0};

    // sample shift register
    logic signed [15:0] shift_reg [0:N-1];
    integer i;

    // pipeline valid
    logic [1:0] vpipe; // adjust width if you pipeline further

    always_ff @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            for (i=0; i<N; i=i+1) shift_reg[i] <= 16'sd0;
            vpipe <= 2'b00;
            sample_out <= 32'sd0;
            valid_out <= 1'b0;
        end else begin
            if (valid_in) begin
                // shift
                for (i=N-1; i>0; i=i-1) shift_reg[i] <= shift_reg[i-1];
                shift_reg[0] <= sample_in;
            end

            // compute MAC combinationally (for small N). For larger N, pipeline the multipliers.
            logic signed [31:0] acc;
            acc = 32'sd0;
            for (i=0; i<N; i=i+1) begin
                // multiply: Q15 * Q15 => Q30 stored in 32-bit signed
                acc = acc + (shift_reg[i] * coeffs[i]);
            end
            sample_out <= acc; // note: acc is Q30 (since inputs and coeffs both Q15). To get Q15, shift right by 15.

            // pipeline valid
            vpipe <= {vpipe[0], valid_in};
            valid_out <= vpipe[1];
        end
    end

endmodule
```

**Notes**

* The multiplier of two Q1.15 numbers produces Q2.30 (effectively Q30 with sign). Summing N terms keeps ~Q30 scale. To convert back to Q1.15, arithmetic right shift by 15 (with rounding) is required.
* For FPGA:  multiply resource usage grows with N. For larger N, implement sequential MAC (one multiplier reused over N cycles) or use DSP blocks and pipeline.

---

## 3) Verilog testbench — `tb_fir_q15.v`

```verilog
// tb_fir_q15.v
`timescale 1ns/1ps
module tb_fir_q15;
    parameter N = 16;
    reg clk = 0;
    reg rst_n;
    reg signed [15:0] sample_in;
    reg valid_in;
    wire signed [31:0] sample_out;
    wire valid_out;

    // Instantiate DUT
    fir_q15 #(.N(N)) dut(.clk(clk), .rst_n(rst_n), .sample_in(sample_in), .valid_in(valid_in), .sample_out(sample_out), .valid_out(valid_out));

    // clock
    always #5 clk = ~clk; // 100 MHz

    integer i;
    initial begin
        rst_n = 0; valid_in = 0; sample_in = 16'sd0;
        #20; rst_n = 1;

        // 1) Impulse test: input = 1.0 in Q15 -> 32767; subsequent samples 0
        @(posedge clk);
        valid_in = 1; sample_in = 16'sd32767; // impulse
        @(posedge clk);
        valid_in = 1; sample_in = 16'sd0;
        for (i=0; i< (N+4); i=i+1) begin
            @(posedge clk);
            sample_in = 16'sd0;
        end
        valid_in = 0;
        #200;

        // 2) Simple waveform test: small sine-like samples (not perfect sine) for manual check
        // example: send alternating values
        for (i=0; i<32; i=i+1) begin
            @(posedge clk);
            valid_in = 1; sample_in = (i % 4 == 0) ? 16'sd20000 : 16'sd-12000;
        end
        valid_in = 0;

        #200;
        $finish;
    end

    // Print outputs when valid_out asserted
    always @(posedge clk) begin
        if (valid_out) begin
            // Print raw accumulator and shifted result
            // Convert Q30 accumulator back to Q15 by arithmetic shift right 15
            $display("%0t ns: sample_out (acc Q30) = %0d, sample_out_Q15 = %0d", $time, sample_out, $signed(sample_out >>> 15));
        end
    end

endmodule
```

**How to plug MATLAB coefficients into Verilog**

1. Run `design_and_export_fir.m` in MATLAB. Open `fir_coeffs_q15.txt` — it contains one integer per line (signed 16-bit). Copy those into the `coeffs` localparam array in `fir_q15.v` replacing the placeholder zeros. The order should match: `coeffs[0]` = h[0], `coeffs[1]` = h[1], ...
2. Re-run Verilog simulation.

---

## 4)Running the simulations

### MATLAB

1. Open MATLAB and run `design_and_export_fir.m`.
2. You will see frequency response, impulse response, and input/output plot. The script prints both the floating coefficients and their Q15 integer equivalents and writes `fir_coeffs_q15.txt`.
3. Copy the Q15 integers into the Verilog `coeffs` array.

### Verilog (Icarus Verilog)

1. Place `fir_q15.v` and `tb_fir_q15.v` in same folder.
2. Compile: `iverilog -o tb_fir tv_fir_q15.v tb_fir_q15.v` (replace filenames as needed). Example: `iverilog -o tb_fir fir_q15.v tb_fir_q15.v`.
3. Run: `vvp tb_fir`.
4. Observe `$display` output lines showing accumulator (Q30) and shifted-to-Q15 results. For the impulse test, the first several `sample_out_Q15` values (after alignment latency) should equal the original floating-point coefficients (within rounding) because impulse response = coefficients.

For ModelSim/Questa, create a project, add files, compile, and run the testbench; use waveform viewer to inspect `sample_out`.

---

## 5) Expected outputs and verification

* **Impulse test**: when the testbench sends an impulse (sample_in = 1.0 -> 32767), the sequence of `sample_out_Q15` printed (after pipeline latency) should equal the quantized coefficient integers `q15` (or very close due to rounding and arithmetic shifts). That directly verifies the filter's impulse response.

* **Sine test**: the input with 2 kHz and 12 kHz in MATLAB should show the 12 kHz component attenuated after filtering. In Verilog, feeding a similar waveform and comparing the output amplitude before/after verifies behaviour.

---

## 6) Tips & Extensions

* For FPGA/ASIC use, prefer using DSP slices and pipeline the MAC; do not use large combinational loops.
* To reduce rounding error, accumulate in wider bitwidth (e.g. 48-bit) and do proper rounding when shifting.
* Implement symmetric-coefficient optimization: if the filter is linear-phase (coeffs symmetric), you can pair coefficients to halve multipliers.
* If you want me to produce: a) a ready-to-run set of coefficients for a specific cutoff and number of taps, b) a sequential Verilog MAC (one multiply per clock) to reduce resource use, or c) an RTL targeting a specific FPGA, tell me the desired specs (num taps, cutoff frequency, sampling freq, fixed-point format), and I will update the code.

---

*End of document.*

# FIR Filter Design — Verilog + MATLAB (Design + Simulation + Testbench)

**Deliverables contained in this document**

* MATLAB script: `design_and_export_fir.m` — designs an FIR (window method), plots responses, filters a test signal, and exports quantized coefficients for Verilog.
* Verilog RTL: `fir_q15.v` — parameterizable fixed-point FIR (Q1.15) supporting N taps.
* Verilog testbench: `tb_fir_q15.v` — applies impulse and a sample waveform, prints outputs for inspection.
* Instructions: How to run MATLAB, how to run Verilog simulation (Icarus/ModelSim), and what outputs to expect.

---

## 1) MATLAB script — `design_and_export_fir.m`

```matlab
% design_and_export_fir.m
% Usage: run this in MATLAB (or Octave with compatible functions)
% - Changes: set fs, cutoff, numTaps
% - It generates: coeffs in floating, plots, applies to test signal, and saves quantized Q15 coefficients to 'fir_coeffs_q15.txt'

clear; close all; clc;

% Parameters
fs = 48000;          % sampling frequency (Hz)
cutoff_hz = 6000;    % desired cutoff frequency (Hz)
numTaps = 16;        % number of taps (even or odd allowed); try 8, 16, 32

% Normalized cutoff (0..1) where 1 corresponds to Nyquist
Wn = cutoff_hz/(fs/2);

% Design: window method (Hamming window) — linear phase
b = fir1(numTaps-1, Wn, hamming(numTaps)); % 'b' are coefficients (length = numTaps)

% Frequency response
[H, f] = freqz(b,1,1024,fs);
figure; subplot(2,1,1);
plot(f, 20*log10(abs(H)+eps)); grid on; xlabel('Frequency (Hz)'); ylabel('Magnitude (dB)');
title(sprintf('%d-tap FIR magnitude response — cutoff %.1f Hz', numTaps, cutoff_hz));
subplot(2,1,2);
plot(f, unwrap(angle(H))); grid on; xlabel('Frequency (Hz)'); ylabel('Phase (radians)');

% Impulse response plot (should equal b)
figure; stem(0:length(b)-1, b, 'filled'); grid on; xlabel('n'); ylabel('h[n]'); title('FIR impulse response (coefficients)');

% Filter a sample signal: sum of two sinusoids (one below cutoff, one above)
t = (0:1/fs:0.01)';
sig = sin(2*pi*2000*t) + 0.6*sin(2*pi*12000*t); % 2 kHz (pass), 12 kHz (stop)
filtered = filter(b,1,sig);
figure; subplot(2,1,1); plot(t, sig); title('Input signal'); xlabel('Time (s)'); grid on;
subplot(2,1,2); plot(t, filtered); title('Filtered output'); xlabel('Time (s)'); grid on;

% Export quantized coefficients for Verilog (Q1.15 format)
% Q15 scaling factor
Q = 15;
scale = 2^Q;
q15 = round(b * scale);
% clamp to signed 16-bit range
q15(q15>32767) = 32767;
q15(q15<-32768) = -32768;

% Save to text file (one integer per line)
fid = fopen('fir_coeffs_q15.txt', 'w');
for k=1:length(q15)
    fprintf(fid, '%d\n', q15(k));
end
fclose(fid);

% Print to console so user can copy into Verilog easily
fprintf('%% MATLAB: Floating-point coefficients (b):\n');
fprintf('b = ['); fprintf(' %.8f', b); fprintf(' ]\n');
fprintf('%% Q15 integers (to put into Verilog array):\n');
fprintf('q15 = ['); fprintf(' %d', q15); fprintf(' ]\n');

fprintf('\nSaved quantized coefficients to fir_coeffs_q15.txt\n');

% Example frequency-domain verification: show attenuation at stopband
stopband_power_before = bandpower(sig, fs, [10000 14000]);
stopband_power_after  = bandpower(filtered, fs, [10000 14000]);
fprintf('Stopband power before: %.6f, after: %.6f (ratio %.2f dB)\n', stopband_power_before, stopband_power_after, 10*log10(stopband_power_before/stopband_power_after));
```

---

## 2) Verilog RTL — `fir_q15.v`

This is a parameterizable, synchronous FIR that accepts signed 16-bit input samples (Q1.15) and produces signed 32-bit accumulator output (you may shift/round to Q1.15 if desired). Coefficients are signed 16-bit Q15 integers (same format as MATLAB export).

```verilog
// fir_q15.v
// Simple direct-form FIR, single-cycle multiply-accumulate per sample (combinational MAC for small tap counts)
module fir_q15 #(
    parameter integer N = 16 // number of taps
) (
    input  logic clk,
    input  logic rst_n,
    input  logic signed [15:0] sample_in, // Q1.15
    input  logic valid_in,
    output logic signed [31:0] sample_out, // accumulator full precision
    output logic valid_out
);

    // Replace the following coefficient vector with the Q15 integers generated by MATLAB
    // Example placeholder values (replace these with actual numbers from fir_coeffs_q15.txt)
    localparam signed [15:0] coeffs [0:N-1] = '{16'sd0,16'sd0,16'sd0,16'sd0,16'sd0,16'sd0,16'sd0,16'sd0,16'sd0,16'sd0,16'sd0,16'sd0,16'sd0,16'sd0,16'sd0,16'sd0};

    // sample shift register
    logic signed [15:0] shift_reg [0:N-1];
    integer i;

    // pipeline valid
    logic [1:0] vpipe; // adjust width if you pipeline further

    always_ff @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            for (i=0; i<N; i=i+1) shift_reg[i] <= 16'sd0;
            vpipe <= 2'b00;
            sample_out <= 32'sd0;
            valid_out <= 1'b0;
        end else begin
            if (valid_in) begin
                // shift
                for (i=N-1; i>0; i=i-1) shift_reg[i] <= shift_reg[i-1];
                shift_reg[0] <= sample_in;
            end

            // compute MAC combinationally (for small N). For larger N, pipeline the multipliers.
            logic signed [31:0] acc;
            acc = 32'sd0;
            for (i=0; i<N; i=i+1) begin
                // multiply: Q15 * Q15 => Q30 stored in 32-bit signed
                acc = acc + (shift_reg[i] * coeffs[i]);
            end
            sample_out <= acc; // note: acc is Q30 (since inputs and coeffs both Q15). To get Q15, shift right by 15.

            // pipeline valid
            vpipe <= {vpipe[0], valid_in};
            valid_out <= vpipe[1];
        end
    end

endmodule
```

**Notes**

* The multiplier of two Q1.15 numbers produces Q2.30 (effectively Q30 with sign). Summing N terms keeps ~Q30 scale. To convert back to Q1.15, arithmetic right shift by 15 (with rounding) is required.
* For FPGA:  multiply resource usage grows with N. For larger N, implement sequential MAC (one multiplier reused over N cycles) or use DSP blocks and pipeline.

---

## 3) Verilog testbench — `tb_fir_q15.v`

```verilog
// tb_fir_q15.v
`timescale 1ns/1ps
module tb_fir_q15;
    parameter N = 16;
    reg clk = 0;
    reg rst_n;
    reg signed [15:0] sample_in;
    reg valid_in;
    wire signed [31:0] sample_out;
    wire valid_out;

    // Instantiate DUT
    fir_q15 #(.N(N)) dut(.clk(clk), .rst_n(rst_n), .sample_in(sample_in), .valid_in(valid_in), .sample_out(sample_out), .valid_out(valid_out));

    // clock
    always #5 clk = ~clk; // 100 MHz

    integer i;
    initial begin
        rst_n = 0; valid_in = 0; sample_in = 16'sd0;
        #20; rst_n = 1;

        // 1) Impulse test: input = 1.0 in Q15 -> 32767; subsequent samples 0
        @(posedge clk);
        valid_in = 1; sample_in = 16'sd32767; // impulse
        @(posedge clk);
        valid_in = 1; sample_in = 16'sd0;
        for (i=0; i< (N+4); i=i+1) begin
            @(posedge clk);
            sample_in = 16'sd0;
        end
        valid_in = 0;
        #200;

        // 2) Simple waveform test: small sine-like samples (not perfect sine) for manual check
        // example: send alternating values
        for (i=0; i<32; i=i+1) begin
            @(posedge clk);
            valid_in = 1; sample_in = (i % 4 == 0) ? 16'sd20000 : 16'sd-12000;
        end
        valid_in = 0;

        #200;
        $finish;
    end

    // Print outputs when valid_out asserted
    always @(posedge clk) begin
        if (valid_out) begin
            // Print raw accumulator and shifted result
            // Convert Q30 accumulator back to Q15 by arithmetic shift right 15
            $display("%0t ns: sample_out (acc Q30) = %0d, sample_out_Q15 = %0d", $time, sample_out, $signed(sample_out >>> 15));
        end
    end

endmodule
```

**How to plug MATLAB coefficients into Verilog**

1. Run `design_and_export_fir.m` in MATLAB. Open `fir_coeffs_q15.txt` — it contains one integer per line (signed 16-bit). Copy those into the `coeffs` localparam array in `fir_q15.v` replacing the placeholder zeros. The order should match: `coeffs[0]` = h[0], `coeffs[1]` = h[1], ...
2. Re-run Verilog simulation.

---

## 4)Running the simulations

### MATLAB

1. Open MATLAB and run `design_and_export_fir.m`.
2. You will see frequency response, impulse response, and input/output plot. The script prints both the floating coefficients and their Q15 integer equivalents and writes `fir_coeffs_q15.txt`.
3. Copy the Q15 integers into the Verilog `coeffs` array.

### Verilog (Icarus Verilog)

1. Place `fir_q15.v` and `tb_fir_q15.v` in same folder.
2. Compile: `iverilog -o tb_fir tv_fir_q15.v tb_fir_q15.v` (replace filenames as needed). Example: `iverilog -o tb_fir fir_q15.v tb_fir_q15.v`.
3. Run: `vvp tb_fir`.
4. Observe `$display` output lines showing accumulator (Q30) and shifted-to-Q15 results. For the impulse test, the first several `sample_out_Q15` values (after alignment latency) should equal the original floating-point coefficients (within rounding) because impulse response = coefficients.

For ModelSim/Questa, create a project, add files, compile, and run the testbench; use waveform viewer to inspect `sample_out`.

---

## 5) Expected outputs and verification

* **Impulse test**: when the testbench sends an impulse (sample_in = 1.0 -> 32767), the sequence of `sample_out_Q15` printed (after pipeline latency) should equal the quantized coefficient integers `q15` (or very close due to rounding and arithmetic shifts). That directly verifies the filter's impulse response.

* **Sine test**: the input with 2 kHz and 12 kHz in MATLAB should show the 12 kHz component attenuated after filtering. In Verilog, feeding a similar waveform and comparing the output amplitude before/after verifies behaviour.

---

## 6) Tips & Extensions

* For FPGA/ASIC use, prefer using DSP slices and pipeline the MAC; do not use large combinational loops.
* To reduce rounding error, accumulate in wider bitwidth (e.g. 48-bit) and do proper rounding when shifting.
* Implement symmetric-coefficient optimization: if the filter is linear-phase (coeffs symmetric), you can pair coefficients to halve multipliers.
* If you want me to produce: a) a ready-to-run set of coefficients for a specific cutoff and number of taps, b) a sequential Verilog MAC (one multiply per clock) to reduce resource use, or c) an RTL targeting a specific FPGA, tell me the desired specs (num taps, cutoff frequency, sampling freq, fixed-point format), and I will update the code.

---

*End of document.*

